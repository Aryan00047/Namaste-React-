Redux:

Redux is not mandatory.... Most people start using from day one but they don't know if it is even requierd?
React and Redux are different libraries.
Zustand is also a state management library --- used in many companies. Like this there are many state management libraries.

Advantages of using Redux:
Applicatoins become easier to debug. (using Redux Dev Tools)

Redux is used mostly used with React but it is also used with other frameworks and libraries.
There are two librries of redus: React Redux and Redux Toolkit
React-Redux is a bridge between React and Redux. 

Today, we are going to learn Redux Toolkit: It is a modern way to write code and most tutorials are on  old way of writig redux.
Redux comes with a huge learning curve and vanilla redux was more complicated than redux-tookit.

Slices in redux store means seperate logical parts for diffreent usecases.

We can't directly modify the slices. First we have to dispatch action. Then it calls a Reducer function and that function modifies the slice of the store.

For Writing Data:
ADD Button in menu ---> dispatches action ---> calls a function(Reducer) ---> internally modifies cart slice.

For Reading Data:
We use Selector for this.

Cart Slice ---> Selector ---> Cart Symbol in header reads the data

This phenomenon of using selector is known as subscribing to the store.(data is in sync with the store)


Click Add ---> Dispatches action ---> Reducer Fn called ---> slice of the store modified --->      selector is used    ---> cart icon is updated
                                                                                              (subscribing to the store)

We will install @reduxjs/toolkit and react-redux
Build our Store
Connect our store to the app
Slice (cartSlice)
Dispatch(action)
Selector

configureStore is imported from redu toolkit.

Provider is imported from react-redux.

It takes a configuration to create a slice:
1. name
2. initial State --- objet
3. reducers --- object: contains action with reducer fn attatched to it. 
Reducer fn gets two params state and action

can avoid writing action when not needed

//this is the syntax given by redux for exporting
export const {addItem, removeItem, clearCart} = cartSlice.actions;
export default cartSlice.reducer;

cartSlice will look :
cartSlice:{
    actions:{},
    reducer
}

thats why we are exporint action and reducer seperately

We modify state based on the action.

adding slice to the store:

big stores also have reducers:
so configureStore({
    reducer:{this reducers contain small reducers
        cart: cartReducer,
    },
});

Subscribing to the store:
A selector is ok inside react

 onClick={() => handleAddItem(item)} --- don't do onClick = {handleClick(item)}

 What is the difference b/w onClick = {handleClick(item)} and onClick = {() => handleClick(item)} and onClick = {handleClick} ?

 Interview Question:
 Whenever you are creating selector, make sure you are subscribing to the right portino of the store, otherwise it will be a 
 huge performance issue.
  const store = useSelector((store) => store)
  const cartItems = store.cart.items;

  this is a wrog way because we will be subscribing to whole store and checking updates for all items in the store. But this will
  lead to a huge performance issue because redix is a power heavy tool.

  In store we have reducer(which contains multiple reducer) and in slices we have reducers(because here we have many reducer fns)

  A Reducer can be a combination of small reducers and Reducers is a combination of small reducer fns.

  <History of Redux:> (This will be very important during interviews)

  Vanilla Redux:
    //vanilla redux => Don't mutate the state
    //create new state and modify that
        const newState = [...state];
        newState.items.push(action.payload);

Earlier returning was mandatory, now its not(redux take care of it automatically)

  //Redux Toolkit - says Mutate the state
            //mutating the state here
            state.items.push(action.payload); 

Even if we are mutating direclty, behind the scenes redux is again creating immutable state....
Its just developers don't have to take care of it.
Redux behind the scenes uses immer

clearCart: (state) => {//can avoid writing action when not needed,
            state.items.length = 0;            
        },
here if we do state = [];
it won't work .... , It just adds a reference to th state.
Also. state is a local variable and if we do state = [], then state chages locally not globally

//original state : {
    items:[]
}
in clearCart we can do two things:
state.items.length === 0;
or return {items: []} // this new object will be replaced inside original state [].

RTK says: Either you can mutate the state or return a new state.

Redux Dev Tools: It is a very powerful tool for debugging and tracking states or how ui will look at certain state.

RTK Query:  In older versions of Redux, we used to use middlewares like redux thunkx.
Go and see the documentation and try to work on RTK yourself.

Why to write test cases?
Testing is a huge domain itself.
Different types of testing a developer can do: 
1. Manual Testing
2. Code

Three types of Testing that a developer can do:
1. Unit Testing --- Test components in isolation
2. Integeration Testing --- Testing integeration of the components
3. End to End(e2e) Testing --- Testing a react application as soon as user lands on the page until it exits the page.
(Requires different types of tools).

As a developer we are majorly concerned about first two types of testing.

We are going to use React Testing Library: Built on top of DOM Testing library. It comes with create-react-app.
We have written every code from scratch, we need to integerate RTL ourselves.

RTL uses jest. Jest is a delightful JS Testing Framework. RTL needs jest also. Jest uses babel.

__tests__ ---> all test files will be here and jest looks for a format to know which files are test files
like spec.ts, .js, .ts