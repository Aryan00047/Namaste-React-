Monolith v/s MicroServices

Monolith has everything inside it
    - Api
    - UI
    - Auth
    - DB
    - SMS
    -....
Microservices 

(These are different services)
Backend, UI, AUTH, DB, SMS, EMAIL.... --- These are microservices and combined together forms a big app
These services have to interct with each other.

The project we are making is UI microservice, and advantage is we can have different tech stack for different microservice.
(for ex: UI in react, backend in node, DB in sql, SMS in java, email in python)

How these services are connected --- all these services runs on their specific ports.
On different ports, we can deploy different services..
All these ports can be mapped to a domain name --- for ex /sms, /ui, /email and so on.... 

How do these services interact?
They will make call to specific ports or maps (/sms) of services they want to interact with.

There are two approaches on how backend(api) interacts with ui:
1. As soon as page loads, we can make an api call, wait for data to come and render the ui.
Suppose api will take 500ms, and after 500ms our ui renders

2. As soon as page loads, we will render our UI, now we will make an api call. As soon as we get api data, we will render our 
application(ui) with the data

In react, we will be using second approach and it is a better approach and gives us a better UX.
Why?
Because in first approach, our page is not render for 500ms and after that suddenly loads.
But with second approach, we load the page and load whatever we can (skeleton) and then slowly the website loads.
With this, website doesn't lags and runs smoothly. Render cycles are very fast, so we don't have to bother about how much times we are 
rendering, we bother but not for rendering 2 times....

React useEffect() hook:
useEffect(()=>{}, [dependency])--- takes two arguments --- 
When will it be called? After the component renders

fetch() -- superpower that js engine have, it is given to us by browsers not javascript

async/await -- practice that industry follows

cors extension to bypass cors error while calling apis from other domains(swiggy)

optional chaining --- it is a good way of handling data 
?.data?.dat....

showing a spinner is not a good way and in the industry, there is concept known as shimmer UI
--- it means we load the fake page, until we render the actual UI ---- it is very important these days... much better User experience

When user see shimmer ui , it makes fake impression that cards are coing here, and user does not feel website is low,
and its very helpful for eyes also as page is smooth --- conditional rendering  is used here (component rendered according to 
condition)

ternary operator ? :

As soon as some part inside a component changes, whole component gets rendered, not that specific part( for example buttonName)
useState is used to track the values, as it cannot track the updated elements using js only. React will not get rendered unless its 
state changes.

onChange() --- it is an important method , it is used to update values of textbox that are bind by state, without this, default state 
value persists and new value never gets entered....
Each time you eneter a keyword, or a character, react re renders the component because onChange is getting called and state is updating 
everytime, and react compares old virtual dom with new one.... for 94 chars, 94 times it is rendering, but react updates only the
updated value, not all things in the component, that's why it is fast

Whenever we change local state variable of react, react re renders the component

Whenver, State React Variabl updates react triggers reconcilation cycle(re-renders the component)